from fastapi import HTTPException, status, UploadFile
from typing import Dict, Any
from tortoise.transactions import in_transaction
from datetime import datetime, timezone
import json
import os
from uuid import uuid4
from pathlib import Path
import aiofiles

from models.tests import (
    Speaking,
    SpeakingAnswer,
    SpeakingQuestion,
    SpeakingStatus,
    TestTypeEnum,
    SpeakingPart,
)
from services.analyses import SpeakingAnalyseService
from services.chatgpt.speaking_integration import ChatGPTSpeakingIntegration
from utils.get_actual_price import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User
from config import BASE_DIR

MEDIA_ROOT = BASE_DIR / "media" / "user_audios"
MEDIA_ROOT.mkdir(parents=True, exist_ok=True)

PART_MAP = {
    "part1": SpeakingPart.PART_1.value,
    "part2": SpeakingPart.PART_2.value,
    "part3": SpeakingPart.PART_3.value,
}


async def save_upload_file_async(upload_file: UploadFile, folder: Path = MEDIA_ROOT) -> str:
    ext = os.path.splitext(upload_file.filename)[1]
    filename = f"{uuid4().hex}{ext}"
    file_path = folder / filename
    async with aiofiles.open(file_path, "wb") as out_file:
        while True:
            chunk = await upload_file.read(1024 * 1024)
            if not chunk:
                break
            await out_file.write(chunk)
    await upload_file.seek(0)
    return str(file_path.relative_to(BASE_DIR))


class SpeakingService:
    """
    Service for managing speaking tests and sessions.
    """

    @staticmethod
    async def start_session(user, t: dict) -> Dict[str, Any]:
        """
        Start a new speaking session for a user with questions generated by ChatGPT.
        """
        price = await get_user_actual_test_price(user, TestTypeEnum.SPEAKING_ENG)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t["insufficient_tokens"]
            )

        chatgpt = ChatGPTSpeakingIntegration()
        try:
            questions_data = await chatgpt.generate_ielts_speaking_questions()
        except Exception:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t["question_generation_failed"]
            )

        async with in_transaction():
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_SPEAKING,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t["transaction_description"].format(price=price),
            )

            session = await Speaking.create(
                user_id=user.id,
                start_time=datetime.now(timezone.utc),
                status=SpeakingStatus.STARTED.value,
            )

            for part_key in ["part1", "part2", "part3"]:
                q = questions_data.get(part_key)
                if not q:
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail=t["question_parsing_failed"]
                    )
                await SpeakingQuestion.create(
                    speaking=session,
                    part=PART_MAP[part_key],
                    title=q["title"],
                    content=q["question"],
                )

        return await SpeakingService.get_session(session.id, user.id, t)

    @staticmethod
    async def get_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Retrieve a speaking session and its questions.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        questions = await SpeakingQuestion.filter(speaking=session).order_by("part")
        part_map = {q.part: q for q in questions}
        return {
            "id": session.id,
            "start_time": session.start_time,
            "end_time": session.end_time,
            "status": session.status,
            "questions": {
                "part1": {
                    "id": part_map[SpeakingPart.PART_1.value].id,
                    "title": part_map[SpeakingPart.PART_1.value].title,
                    "content": part_map[SpeakingPart.PART_1.value].content,
                },
                "part2": {
                    "id": part_map[SpeakingPart.PART_2.value].id,
                    "title": part_map[SpeakingPart.PART_2.value].title,
                    "content": part_map[SpeakingPart.PART_2.value].content,
                },
                "part3": {
                    "id": part_map[SpeakingPart.PART_3.value].id,
                    "title": part_map[SpeakingPart.PART_3.value].title,
                    "content": part_map[SpeakingPart.PART_3.value].content,
                },
            },
            "analyse": None,
        }

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, audio_files: Dict[str, UploadFile], t: dict
    ) -> Dict[str, Any]:
        """
        Submit user's audio answers, transcribe them, and perform analysis.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status == SpeakingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed"]
            )

        questions = await SpeakingQuestion.filter(speaking=session).order_by("part")
        if len(questions) != 3:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["invalid_question_count"]
            )

        part_map = {q.part: q for q in questions}
        chatgpt = ChatGPTSpeakingIntegration()

        async with in_transaction():
            answers = {}
            for part_key in ["part1", "part2", "part3"]:
                audio = audio_files.get(part_key)
                if not audio:
                    continue
                question = part_map.get(PART_MAP[part_key])
                if not question:
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail=t["question_not_found"]
                    )
                audio_path = await save_upload_file_async(audio)
                text = await chatgpt.transcribe_audio_file_async(audio)
                answer = await SpeakingAnswer.create(
                    question=question,
                    audio_answer=audio_path,
                    text_answer=text,
                )
                answers[part_key] = answer

            session.status = SpeakingStatus.COMPLETED.value
            session.end_time = datetime.now(timezone.utc)
            await session.save(update_fields=["status", "end_time"])

            # Get analysis and return it
            analyse = await SpeakingAnalyseService.analyse(session.id)
            if not analyse:
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail=t["analysis_not_found"]
                )

        return {
            "message": t["answers_submitted"],
            "analysis": {
                "feedback": analyse["feedback"],
                "overall_band_score": analyse["overall_band_score"],
                "fluency_and_coherence_score": analyse["fluency_and_coherence_score"],
                "fluency_and_coherence_feedback": analyse["fluency_and_coherence_feedback"],
                "lexical_resource_score": analyse["lexical_resource_score"],
                "lexical_resource_feedback": analyse["lexical_resource_feedback"],
                "grammatical_range_and_accuracy_score": analyse["grammatical_range_and_accuracy_score"],
                "grammatical_range_and_accuracy_feedback": analyse["grammatical_range_and_accuracy_feedback"],
                "pronunciation_score": analyse["pronunciation_score"],
                "pronunciation_feedback": analyse["pronunciation_feedback"],
                "timing": analyse["timing"],
            },
        }

    @staticmethod
    async def cancel_session(session_id: int, user_id: int, t: dict) -> dict:
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status in [SpeakingStatus.COMPLETED.value, SpeakingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["cannot_cancel_session"]
            )

        session.status = SpeakingStatus.CANCELLED.value
        await session.save(update_fields=["status"])
        return {"message": t["session_cancelled"]}

    @staticmethod
    async def restart_session(session_id: int, user_id: int, t: dict) -> dict:
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status not in [SpeakingStatus.COMPLETED.value, SpeakingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["cannot_restart_session"]
            )

        await SpeakingAnswer.filter(question__speaking=session).delete()
        session.status = SpeakingStatus.STARTED.value
        session.start_time = datetime.now(timezone.utc)
        session.end_time = None
        await session.save(update_fields=["status", "start_time", "end_time"])
        return {"message": t["session_restarted"]}
    
    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Get or create analysis for a completed speaking session.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        if session.status != SpeakingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_not_completed"]
            )
        analyse = await SpeakingAnalyseService.analyse(session.id)
        return {
            "analysis": {
                "feedback": analyse["feedback"],
                "overall_band_score": analyse["overall_band_score"],
                "fluency_and_coherence_score": analyse["fluency_and_coherence_score"],
                "fluency_and_coherence_feedback": analyse["fluency_and_coherence_feedback"],
                "lexical_resource_score": analyse["lexical_resource_score"],
                "lexical_resource_feedback": analyse["lexical_resource_feedback"],
                "grammatical_range_and_accuracy_score": analyse["grammatical_range_and_accuracy_score"],
                "grammatical_range_and_accuracy_feedback": analyse["grammatical_range_and_accuracy_feedback"],
                "pronunciation_score": analyse["pronunciation_score"],
                "pronunciation_feedback": analyse["pronunciation_feedback"],
                "timing": analyse["timing"],
            }
        }

