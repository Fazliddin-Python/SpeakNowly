from datetime import datetime, timezone
from typing import Dict, Any
import json

from fastapi import HTTPException, status, UploadFile
from tortoise.transactions import in_transaction

from models.tests import (
    Speaking,
    SpeakingAnalyse,
    SpeakingAnswer,
    SpeakingQuestion,
    SpeakingStatus,
    TestTypeEnum,
)
from services.analyses import SpeakingAnalyseService
from services.chatgpt.speaking_integration import ChatGPTSpeakingIntegration
from utils.get_actual_price import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User


class SpeakingService:
    """
    Service for managing speaking tests and sessions.
    """

    @staticmethod
    async def start_session(user, t: dict) -> Dict[str, Any]:
        """
        Start a new speaking session for a user with questions generated by ChatGPT.
        """
        price = await get_user_actual_test_price(user, TestTypeEnum.SPEAKING_ENG)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t["insufficient_tokens"]
            )

        chatgpt = ChatGPTSpeakingIntegration()
        try:
            questions_data = await chatgpt.generate_ielts_speaking_questions()
        except Exception:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t["question_generation_failed"]
            )

        async with in_transaction():
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_SPEAKING,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t["transaction_description"].format(price=price),
            )

            session = await Speaking.create(
                user_id=user.id,
                start_time=datetime.now(timezone.utc),
                status=SpeakingStatus.STARTED.value,
            )

            for part_key in ["part1", "part2", "part3"]:
                q = questions_data.get(part_key)
                if not q:
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail=t["question_parsing_failed"]
                    )
                await SpeakingQuestion.create(
                    speaking=session,
                    part=part_key,
                    title=q["title"],
                    content=q["question"],
                )

        return await SpeakingService.get_session(session.id, user.id, t)

    @staticmethod
    async def get_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Retrieve a speaking session and its questions.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        questions = await SpeakingQuestion.filter(speaking=session).order_by("part")
        return {
            "session_id": session.id,
            "start_time": session.start_time,
            "status": session.status,
            "questions": [
                {
                    "id": q.id,
                    "part": q.part,
                    "title": q.title,
                    "content": q.content,
                }
                for q in questions
            ],
        }

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, audio_files: Dict[str, UploadFile], t: dict
    ) -> Dict[str, Any]:
        """
        Submit user's audio answers, transcribe them, and perform analysis.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status == SpeakingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed"]
            )

        questions = await SpeakingQuestion.filter(speaking=session).order_by("part")
        if len(questions) != 3:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["invalid_question_count"]
            )

        part_map = {q.part: q for q in questions}
        chatgpt = ChatGPTSpeakingIntegration()

        async with in_transaction():
            answers = {}
            for part_key in ["part1", "part2", "part3"]:
                audio = audio_files.get(part_key)
                if not audio:
                    continue
                question = part_map.get(part_key)
                if not question:
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail=t["question_not_found"]
                    )
                # Use async transcription from integration
                text = await chatgpt.transcribe_audio_file_async(audio)
                answer = await SpeakingAnswer.create(
                    question=question,
                    audio_answer=audio.filename,
                    text_answer=text,
                )
                answers[part_key] = answer

            if len(answers) != 3:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=t["not_all_audio_uploaded"]
                )

            session.status = SpeakingStatus.COMPLETED.value
            session.end_time = datetime.now(timezone.utc)
            await session.save(update_fields=["status", "end_time"])

            # Get analysis and return it
            analyse = await SpeakingAnalyseService.analyse(session.id)
            if not analyse:
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail=t["analysis_not_found"]
                )

        return {
            "message": t["answers_submitted"],
            "analysis": {
                "feedback": analyse.feedback,
                "overall_band_score": float(analyse.overall_band_score) if analyse.overall_band_score is not None else None,
                "fluency_and_coherence_score": float(analyse.fluency_and_coherence_score) if analyse.fluency_and_coherence_score is not None else None,
                "fluency_and_coherence_feedback": analyse.fluency_and_coherence_feedback,
                "lexical_resource_score": float(analyse.lexical_resource_score) if analyse.lexical_resource_score is not None else None,
                "lexical_resource_feedback": analyse.lexical_resource_feedback,
                "grammatical_range_and_accuracy_score": float(analyse.grammatical_range_and_accuracy_score) if analyse.grammatical_range_and_accuracy_score is not None else None,
                "grammatical_range_and_accuracy_feedback": analyse.grammatical_range_and_accuracy_feedback,
                "pronunciation_score": float(analyse.pronunciation_score) if analyse.pronunciation_score is not None else None,
                "pronunciation_feedback": analyse.pronunciation_feedback,
                "timing": analyse.duration.total_seconds() if analyse.duration else None,
            },
        }

    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Get or create analysis for a completed speaking session.
        """
        session = await Speaking.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        if session.status != SpeakingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_not_completed"]
            )
        analyse = await SpeakingAnalyseService.analyse(session.id)
        return {
            "analysis": {
                "feedback": analyse.feedback,
                "overall_band_score": float(analyse.overall_band_score) if analyse.overall_band_score is not None else None,
                "fluency_and_coherence_score": float(analyse.fluency_and_coherence_score) if analyse.fluency_and_coherence_score is not None else None,
                "fluency_and_coherence_feedback": analyse.fluency_and_coherence_feedback,
                "lexical_resource_score": float(analyse.lexical_resource_score) if analyse.lexical_resource_score is not None else None,
                "lexical_resource_feedback": analyse.lexical_resource_feedback,
                "grammatical_range_and_accuracy_score": float(analyse.grammatical_range_and_accuracy_score) if analyse.grammatical_range_and_accuracy_score is not None else None,
                "grammatical_range_and_accuracy_feedback": analyse.grammatical_range_and_accuracy_feedback,
                "pronunciation_score": float(analyse.pronunciation_score) if analyse.pronunciation_score is not None else None,
                "pronunciation_feedback": analyse.pronunciation_feedback,
                "timing": analyse.duration.total_seconds() if analyse.duration else None,
            }
        }
