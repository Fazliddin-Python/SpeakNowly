from fastapi import HTTPException, status
from typing import List, Dict, Any
from tortoise.transactions import in_transaction
from datetime import datetime, timedelta, timezone
import json

from models.tests import (
    ReadingPassage, ReadingQuestion, ReadingVariant,
    Reading, ReadingAnswer,
    Constants, TestTypeEnum
)
from services.analyses import ReadingAnalyseService
from services.chatgpt import ChatGPTReadingIntegration
from utils import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User

DIFFICULTY_ORDER = ["easy", "medium", "hard"]

async def get_user_reading_level(user_id: int) -> str:
    """
    Determines the difficulty level for a new test based on the user's history.
    """
    # Get the last 3 completed tests of the user
    recent_sessions = await Reading.filter(
        user_id=user_id,
        status=Constants.ReadingStatus.COMPLETED.value
    ).order_by("-end_time").limit(3)

    if not recent_sessions or len(recent_sessions) < 3:
        return "easy"  # Beginner or not enough data

    # Calculate the average score for the last 3 tests
    avg_score = sum([float(s.score or 0) for s in recent_sessions]) / len(recent_sessions)

    # Get the current level (from the last test)
    last_level = getattr(recent_sessions[0], "level", None) or "easy"
    if last_level not in DIFFICULTY_ORDER:
        last_level = "easy"

    # Logic for increasing/decreasing level
    if avg_score >= 32 and last_level == "easy":
        return "medium"
    elif avg_score >= 32 and last_level == "medium":
        return "hard"
    elif avg_score < 25 and last_level == "medium":
        return "easy"
    elif avg_score < 25 and last_level == "hard":
        return "medium"
    else:
        return last_level


class ReadingService:
    """
    Service for managing reading tests and sessions.
    """

    @staticmethod
    async def start_session(user_id: int, t: dict) -> Dict[str, Any]:
        """
        Start a new reading session for a user with a test generated by ChatGPT.
        """
        user = await User.get_or_none(id=user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["user_not_found"]
            )

        level = await get_user_reading_level(user_id)

        price = await get_user_actual_test_price(user, TestTypeEnum.READING_ENG.value)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t["insufficient_tokens"]
            )

        chatgpt = ChatGPTReadingIntegration()
        try:
            generated_test = await chatgpt.generate_reading_test(level=level)
        except Exception:
            raise HTTPException(status_code=500, detail=t["test_generation_failed"])

        # Flexible JSON parsing
        if not generated_test or not str(generated_test).strip():
            raise HTTPException(status_code=500, detail=t["test_generation_failed"])
        try:
            data = str(generated_test).strip()
            if data.startswith("```json"):
                data = data[7:]
            if data.startswith("```"):
                data = data[3:]
            if data.endswith("```"):
                data = data[:-3]
            data = data.strip()
            test_data = json.loads(data)
        except Exception as e:
            print("ChatGPT error:", e)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t["test_generation_failed"]
            )

        passages = test_data if isinstance(test_data, list) else test_data.get("passages", [])
        if not isinstance(passages, list) or len(passages) < 3:
            raise HTTPException(status_code=400, detail=t["not_enough_passages"])
        total_questions = sum(len(p.get("questions", [])) for p in passages)
        if total_questions != 40:
            raise HTTPException(status_code=400, detail=f"Generated test contains {total_questions} questions, expected 40")

        async with in_transaction():
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_READING.value,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t["transaction_description"].format(price=price),
            )
            start_time = datetime.now(timezone.utc)
            end_time = start_time + timedelta(minutes=60)
            session = await Reading.create(
                user_id=user.id,
                start_time=datetime.now(timezone.utc),
                end_time=None,
                status=Constants.ReadingStatus.STARTED.value,
                score=0.0,
                level=level,
            )
            for passage_data in passages:
                passage = await ReadingPassage.create(
                    title=passage_data.get("title"),
                    text=passage_data.get("text") or passage_data.get("passage"),
                    skills=passage_data.get("skills") or passage_data.get("skill", ""),
                    level=level,
                )
                await session.passages.add(passage)
                for q in passage_data.get("questions", []):
                    q_type = q.get("type")
                    if not q_type:
                        if isinstance(q.get("answers", None), list) and len(q["answers"]) == 0 and q.get("text"):
                            q_type = "TEXT"
                        elif isinstance(q.get("answers", None), list) and len(q["answers"]) > 0:
                            q_type = "MULTIPLE_CHOICE"
                        else:
                            raise HTTPException(status_code=500, detail=f"Incorrect question: could not determine type: {q}")
                    question = await ReadingQuestion.create(
                        passage=passage,
                        text=q["text"],
                        type=q_type,
                        score=q.get("score", 1),
                    )
                    for v in q.get("answers", []):
                        await ReadingVariant.create(
                            question=question,
                            text=v["text"],
                            is_correct=v.get("is_correct", False),
                        )
            await ReadingService._create_blank_answers(session)
        return await ReadingService._format_session_data(session)

    @staticmethod
    async def _create_blank_answers(session: Reading):
        """
        Create blank answers for all questions in the reading session.
        """
        questions = []
        for passage in await session.passages.all():
            questions.extend(await passage.questions.all())

        answers = [
            ReadingAnswer(
                user_id=session.user_id,
                reading_id=session.id,
                question_id=question.id,
                status=ReadingAnswer.NOT_ANSWERED,
            )
            for question in questions
        ]
        await ReadingAnswer.bulk_create(answers)

    @staticmethod
    async def _format_session_data(session: Reading) -> Dict[str, Any]:
        """
        Format reading session data for response.
        """
        passages = await session.passages.all().order_by("id")
        return {
            "id": session.id,
            "start_time": session.start_time,
            "end_time": session.end_time,
            "passages": [
                {
                    "id": passage.id,
                    "title": passage.title,
                    "skills": passage.skills,
                    "questions_count": await passage.questions.all().count(),
                }
                for passage in passages
            ],
        }

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, passage_id: int, answers: List[Dict[str, Any]], t: dict
    ) -> int:
        """
        Save answers for a reading session passage. No analysis here!
        Only checks session status.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed_or_cancelled"]
            )

        async with in_transaction():
            for ans in answers:
                await ReadingAnswer.update_or_create(
                    defaults={
                        "text": ans.get("answer", "").strip(),
                        "status": ReadingAnswer.ANSWERED,
                    },
                    user_id=user_id,
                    reading_id=session_id,
                    question_id=ans["question_id"],
                )
        return len(answers)

    @staticmethod
    async def finish_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        session = await Reading.get_or_none(id=session_id, user_id=user_id).prefetch_related("passages")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        # if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
        #     raise HTTPException(
        #         status_code=status.HTTP_400_BAD_REQUEST,
        #         detail=t["session_already_completed_or_cancelled"]
        #     )

        session.status = Constants.ReadingStatus.COMPLETED.value
        session.end_time = datetime.now(timezone.utc)
        await session.save()

        await ReadingAnalyseService.analyse(session_id, user_id)
        return await ReadingService._full_analysis_response(session, user_id)

    @staticmethod
    async def cancel_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed_or_cancelled"]
            )

        session.status = Constants.ReadingStatus.CANCELLED.value
        await session.save(update_fields=["status"])
        return {"message": t["session_cancelled"]}

    @staticmethod
    async def restart_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Restart a reading session.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status == Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed"]
            )

        session.status = Constants.ReadingStatus.PENDING.value
        session.end_time = session.end_time + timedelta(minutes=20)
        await session.save()
        await ReadingAnswer.filter(reading_id=session_id, user_id=user_id).delete()
        return {"message": t["session_restarted"]}

    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        session = await Reading.get_or_none(id=session_id, user_id=user_id).prefetch_related("passages")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        if session.status != Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_not_completed"]
            )
        return await ReadingService._full_analysis_response(session, user_id)

    @staticmethod
    async def _full_analysis_response(session, user_id) -> Dict[str, Any]:
        # Load passages and questions
        passages = await session.passages.all().prefetch_related("questions__variants")
        passage_ids = [p.id for p in passages]

        # Load existing analyses and answers
        analyses = await ReadingAnalyseService.get_all_analyses(session.id, user_id)
        analyses_by_pid = {a.passage_id: a for a in analyses}
        answers = await ReadingAnswer.filter(
            user_id=user_id,
            reading_id=session.id,
            question_id__in=[q.id for p in passages for q in p.questions]
        ).prefetch_related("question")
        answers_by_qid = {a.question_id: a for a in answers}

        passage_results = []
        total_correct = total_questions = 0

        for passage in passages:
            analyse = analyses_by_pid.get(passage.id)
            if not analyse:
                # Skip passages without submitted answers
                continue

            question_results = []
            for question in passage.questions:
                ans = answers_by_qid.get(question.id)
                # Default values
                user_ans = ans.text or ""
                is_corr = bool(ans.is_correct) if ans else False
                corr_ans = ans.correct_answer or ""
                expl = ans.explanation or ""
                question_results.append({
                    "id": question.id,
                    "text": question.text,
                    "type": question.type,
                    "answers": [
                        {"id": v.id, "text": v.text, "is_correct": v.is_correct}
                        for v in question.variants
                    ],
                    "user_answer": user_ans,
                    "correct_answer": corr_ans,
                    "explanation": expl,
                    "is_correct": is_corr,
                })
                total_questions += 1
                if is_corr:
                    total_correct += 1

            passage_results.append({
                "id": passage.id,
                "title": passage.title,
                "text": passage.text,
                "questions": question_results,
                "overall_score": float(analyse.overall_score),
                "timing": analyse.duration.total_seconds() if analyse.duration else 0,
            })

        # Compute overall IELTS band
        if analyses:
            avg = sum(a.overall_score for a in analyses) / len(analyses)
            # Round to nearest half
            band = round(avg * 2) / 2
        else:
            band = 0.0

        elapsed = (session.end_time - session.start_time).total_seconds() / 60

        return {
            "score": round(band, 2),
            "correct": f"{total_correct}/{total_questions}",
            "time": round(elapsed, 2),
            "start_time": session.start_time,
            "end_time": session.end_time,
            "passages": passage_results,
        }
