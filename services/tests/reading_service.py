from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any
import json

from fastapi import HTTPException, status
from tortoise.transactions import in_transaction

from models.tests import (
    ReadingPassage, ReadingQuestion, ReadingVariant,
    Reading, ReadingAnswer,
    Constants, TestTypeEnum
)
from services.analyses import ReadingAnalyseService
from services.chatgpt import ChatGPTReadingIntegration
from utils import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User


class ReadingService:
    """
    Service for managing reading tests and sessions.
    """

    @staticmethod
    async def start_session(user_id: int, t: dict) -> Dict[str, Any]:
        """
        Start a new reading session for a user with a test generated by ChatGPT.
        """
        user = await User.get_or_none(id=user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["user_not_found"]
            )

        price = await get_user_actual_test_price(user, TestTypeEnum.READING_ENG.value)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t["insufficient_tokens"]
            )

        chatgpt = ChatGPTReadingIntegration()
        try:
            generated_test = await chatgpt.generate_reading_test(level="Intermediate")
        except Exception:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t["test_generation_failed"]
            )

        try:
            test_data = json.loads(generated_test)
        except json.JSONDecodeError:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t["test_parsing_failed"]
            )

        passages = test_data.get("passages", [])
        if len(passages) < 3:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["not_enough_passages"]
            )

        async with in_transaction():
            # Deduct tokens
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_READING.value,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t["transaction_description"].format(price=price),
            )

            # Create reading session
            start_time = datetime.now(timezone.utc)
            end_time = start_time + timedelta(minutes=60)
            session = await Reading.create(
                user_id=user.id,
                start_time=start_time,
                end_time=end_time,
                status=Constants.ReadingStatus.STARTED.value,
                score=0.0,
            )

            # Create passages, questions, and variants
            for passage_data in passages:
                passage = await ReadingPassage.create(
                    title=passage_data["title"],
                    text=passage_data["text"],
                    skills=passage_data.get("skills", ""),
                    level=passage_data.get("level", "Intermediate"),
                )
                await session.passages.add(passage)

                for question_data in passage_data.get("questions", []):
                    question = await ReadingQuestion.create(
                        passage=passage,
                        text=question_data["text"],
                        question_type=question_data["type"],
                    )
                    for variant_data in question_data.get("variants", []):
                        await ReadingVariant.create(
                            question=question,
                            text=variant_data["text"],
                            is_correct=variant_data.get("is_correct", False),
                        )

            # Create blank answers for all questions
            await ReadingService._create_blank_answers(session)

        return await ReadingService._format_session_data(session)

    @staticmethod
    async def _create_blank_answers(session: Reading):
        """
        Create blank answers for all questions in the reading session.
        """
        questions = []
        for passage in await session.passages.all():
            questions.extend(await passage.questions.all())

        answers = [
            ReadingAnswer(
                user_id=session.user_id,
                reading_id=session.id,
                question_id=question.id,
                status=ReadingAnswer.NOT_ANSWERED.value,
            )
            for question in questions
        ]
        await ReadingAnswer.bulk_create(answers)

    @staticmethod
    async def _format_session_data(session: Reading) -> Dict[str, Any]:
        """
        Format reading session data for response.
        """
        passages = await session.passages.all().order_by("id")
        return {
            "id": session.id,
            "start_time": session.start_time,
            "end_time": session.end_time,
            "passages": [
                {
                    "id": passage.id,
                    "title": passage.title,
                    "skills": passage.skills,
                    "questions_count": await passage.questions.all().count(),
                }
                for passage in passages
            ],
        }

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, passage_id: int, answers: List[Dict[str, Any]], t: dict
    ) -> int:
        """
        Submit answers for a reading session and calculate the total score.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if not await session.passages.filter(id=passage_id).exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["invalid_passage"]
            )

        total_score = 0
        async with in_transaction():
            for ans in answers:
                question = await ReadingQuestion.get_or_none(id=ans["question_id"])
                if not question:
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail=t["question_not_found"]
                    )

                user_answer = ans.get("answer", "").strip()
                correct_variant = await ReadingVariant.filter(question=question, is_correct=True).first()
                is_correct = correct_variant and correct_variant.text.strip().lower() == user_answer.lower()

                if is_correct:
                    total_score += question.score

                await ReadingAnswer.update_or_create(
                    defaults={
                        "text": user_answer,
                        "is_correct": is_correct,
                        "correct_answer": correct_variant.text if correct_variant else "",
                        "status": ReadingAnswer.ANSWERED.value,
                    },
                    user_id=user_id,
                    reading_id=session_id,
                    question_id=question.id,
                )

        return total_score

    @staticmethod
    async def finish_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Finish a reading session and calculate the score.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status == Constants.ReadingStatus.COMPLETED.value:
            return {"message": t["session_already_completed"]}

        session.status = Constants.ReadingStatus.COMPLETED.value
        session.end_time = datetime.now(timezone.utc)
        await session.save()

        analysis = await ReadingAnalyseService.analyse(session_id, user_id)

        return {
            "message": t["session_completed_successfully"],
            "analysis": analysis,
        }

    @staticmethod
    async def cancel_session(session_id: int, user_id: int, t: dict) -> bool:
        """
        Cancel a reading session.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        session.status = Constants.ReadingStatus.CANCELLED.value
        await session.save(update_fields=["status"])
        return True

    @staticmethod
    async def restart_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Restart a reading session.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )

        if session.status == Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_already_completed"]
            )

        session.status = Constants.ReadingStatus.PENDING.value
        session.end_time = session.end_time + timedelta(minutes=20)
        await session.save()

        await ReadingAnswer.filter(reading_id=session_id, user_id=user_id).delete()

        return {
            "message": t["session_restarted_successfully"],
            "start_time": session.start_time,
            "end_time": session.end_time,
        }

    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Get or create analysis for a completed reading session.
        """
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t["session_not_found"]
            )
        if session.status != Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t["session_not_completed"]
            )
        analyses = await ReadingAnalyseService.analyse(session_id, user_id)
        return {
            "analysis": [
                {
                    "passage_id": a.passage_id,
                    "correct_answers": a.correct_answers,
                    "overall_score": float(a.overall_score) if a.overall_score is not None else None,
                    "timing": a.duration.total_seconds() if a.duration else None,
                }
                for a in analyses
            ]
        }