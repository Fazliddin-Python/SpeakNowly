from fastapi import HTTPException, status
from typing import Dict, Any, List
from tortoise.transactions import in_transaction
from datetime import datetime, timezone

from models.tests.writing import (
    Writing,
    WritingTask,
    WritingSession,
    WritingAnswer,
    WritingStatus,
)
from services.analyses.writing_analyse_service import WritingAnalyseService
from services.chatgpt.writing_integration import ChatGPTWritingIntegration
from utils.get_actual_price import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User

class WritingService:
    """
    Service for managing writing tests and sessions.
    """

    @staticmethod
    async def start_session(user, t: dict) -> WritingSession:
        """
        Start a new writing session for a user with questions and diagrams.
        """
        # Check if user has enough tokens
        price = await get_user_actual_test_price(user, TransactionType.TEST_WRITING)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t.get("insufficient_tokens", "Insufficient tokens")
            )

        # Generate questions using ChatGPT
        chatgpt = ChatGPTWritingIntegration()
        part1_data = await chatgpt.generate_writing_part1_question(user_id=user.id)
        part2_data = await chatgpt.generate_writing_part2_question(user_id=user.id)

        # Extract part 1 data
        part1_question = part1_data["question"]
        chart_type = part1_data["chart_type"]
        categories = part1_data["categories"]
        year1 = part1_data["year1"]
        year2 = part1_data["year2"]
        data_year1 = part1_data["data_year1"]
        data_year2 = part1_data["data_year2"]

        # Validate chart type
        if chart_type not in ["bar", "line", "pie"]:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=t.get("unknown_chart_type", "Unknown chart type")
            )

        # Generate diagram
        if chart_type == "bar":
            diagram_path = chatgpt.create_bar_chart(categories, year1, year2, data_year1, data_year2)
        elif chart_type == "line":
            diagram_path = chatgpt.create_line_chart(categories, year1, year2, data_year1, data_year2)
        elif chart_type == "pie":
            diagram_path = chatgpt.create_pie_chart(categories, year1, year2, data_year1, data_year2)
        diagram_path = diagram_path.replace("media/", "")

        part2_question = part2_data["question"]

        # Create test template and tasks (можно кэшировать, если хотите переиспользовать шаблоны)
        async with in_transaction():
            # Deduct tokens
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_WRITING,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t.get("transaction_description", f"Writing test (-{price} tokens)"),
            )

            # Create test template
            test = await Writing.create(
                title=f"IELTS Writing Test {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M')}",
                description="Generated by AI"
            )
            # Create tasks
            diagram_data = {
                "categories": categories,
                "year1": year1,
                "year2": year2,
                "data_year1": data_year1,
                "data_year2": data_year2,
            }
            task1 = await WritingTask.create(
                test=test,
                part=1,
                content=part1_question,
                diagram=diagram_path,
                diagram_data=diagram_data,
            )
            task2 = await WritingTask.create(
                test=test,
                part=2,
                content=part2_question,
            )

            # Create writing session
            session = await WritingSession.create(
                user=user,
                test=test,
                status=WritingStatus.STARTED.value,
                start_time=datetime.now(timezone.utc),
            )

            # Create empty answers
            await WritingAnswer.create(session=session, task=task1, answer="")
            await WritingAnswer.create(session=session, task=task2, answer="")

        return session

    @staticmethod
    async def get_session(session_id: int, user_id: int, t: dict) -> WritingSession:
        """
        Retrieve a writing session and its questions.
        """
        session = await WritingSession.get_or_none(id=session_id, user_id=user_id).prefetch_related("test__tasks", "answers__task")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )
        return session

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, part1_answer: str, part2_answer: str, t: dict
    ) -> Dict[str, Any]:
        """
        Submit answers and perform analysis.
        """
        session = await WritingSession.get_or_none(id=session_id, user_id=user_id).prefetch_related("test__tasks", "answers__task")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )
        if session.status in [WritingStatus.COMPLETED.value, WritingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_already_completed_or_cancelled", "Session already completed or cancelled")
            )

        # Get tasks
        tasks = {task.part: task for task in await WritingTask.filter(test=session.test)}
        answers = {ans.task.part: ans for ans in await WritingAnswer.filter(session=session).prefetch_related("task")}

        # Save answers
        async with in_transaction():
            if part1_answer and 1 in answers:
                answers[1].answer = part1_answer
                await answers[1].save()
            if part2_answer and 2 in answers:
                answers[2].answer = part2_answer
                await answers[2].save()

            session.status = WritingStatus.COMPLETED.value
            session.end_time = datetime.now(timezone.utc)
            await session.save(update_fields=["status", "end_time"])

        # Анализ (можно сделать асинхронно через очередь)
        writing_analyse = await WritingAnalyseService.analyse(session.id)

        return {
            "message": t.get("answers_submitted", "Answers submitted successfully"),
            "analysis": writing_analyse,
        }

    @staticmethod
    async def cancel_session(session_id: int, user_id: int, t: dict) -> dict:
        """
        Cancel a writing session.
        """
        session = await WritingSession.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        if session.status in [WritingStatus.COMPLETED.value, WritingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("cannot_cancel_session", "Cannot cancel completed or already cancelled session")
            )

        session.status = WritingStatus.CANCELLED.value
        await session.save(update_fields=["status"])
        return {"message": t.get("session_cancelled", "Session cancelled")}

    @staticmethod
    async def restart_session(session_id: int, user_id: int, t: dict) -> dict:
        """
        Restart a writing session.
        """
        session = await WritingSession.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        if session.status not in [WritingStatus.COMPLETED.value, WritingStatus.CANCELLED.value, WritingStatus.EXPIRED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("cannot_restart_session", "Cannot restart active session")
            )

        # Reset answers
        answers = await WritingAnswer.filter(session=session)
        for ans in answers:
            ans.answer = ""
            await ans.save(update_fields=["answer"])

        # Reset session
        session.status = WritingStatus.STARTED.value
        session.start_time = datetime.now(timezone.utc)
        session.end_time = None
        await session.save(update_fields=["status", "start_time", "end_time"])
        return {"message": t.get("session_restarted", "Session restarted")}

    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Get analysis for a completed session.
        """
        session = await WritingSession.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )
        if session.status != WritingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_not_completed", "Session not completed")
            )

        analyse = await WritingAnalyseService.analyse(session.id)
        return {"analysis": analyse}
